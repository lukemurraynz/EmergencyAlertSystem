name: CI/CD Pipeline

# ====================
# REQUIRED GitHub Repository Secrets
# ====================
# These secrets must be configured in the repository settings before deployment:
# - AZURE_SUBSCRIPTION_ID: Azure subscription ID (from `az account show --query id`)
# - AZURE_TENANT_ID: Azure tenant ID (from `az account show --query tenantId`)
# - AZURE_CLIENT_ID: Entra ID service principal client ID (for OIDC federation)
#
# NOTE: ACR_NAME is no longer required as a secretâ€”it's automatically created by Bicep
# deployment and retrieved from deployment outputs in the CI/CD pipeline.
#
# NOTE: POSTGRES_ADMIN_PASSWORD is no longer requiredâ€”Bicep auto-generates it and stores
# in Key Vault. The application uses managed identity for database connections.
#
# NOTE: VITE_API_URL is no longer requiredâ€”it's dynamically computed from the AKS
# cluster FQDN during infrastructure deployment and passed to the frontend build.
#
# NOTE: AKS_CLUSTER_NAME and AKS_RESOURCE_GROUP are no longer required as secretsâ€”
# they are automatically created by Bicep deployment and passed via job outputs.
#
# OIDC Federation Setup:
#   az identity federated-credential create \
#     --name "github-actions" \
#     --identity-name "<identity-name>" \
#     --resource-group "<resource-group>" \
#     --issuer "https://token.actions.githubusercontent.com" \
#     --subject "repo:<org>/<repo>:ref:refs/heads/main"
# ====================

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'infrastructure/**'
      - '.github/workflows/ci-cd.yml'
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write   # Required for OIDC authentication to Azure
  contents: write   # Required to create commit comments
  pull-requests: write  # Required to post comments on PRs

env:
  DOTNET_VERSION: '8.0.x'
  NODE_VERSION: '20.x'
  # Azure Configuration (set in GitHub repo secrets)
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}

jobs:
  # ====================
  # Infrastructure: Validate & Deploy
  # ====================
  validate-infrastructure:
    name: Validate Infrastructure
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        # SHA pin: actions/checkout v4.2.2 (2024-10-31)
        # Verify: https://github.com/actions/checkout/releases
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Azure Login (OIDC)
        # SHA pin: azure/login v2.2.0 (2024-10-10)
        uses: azure/login@a65d910e8af852a8061c627c456678983e180302
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Set Azure subscription context
        run: az account set --subscription ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Validate Bicep syntax
        run: |
          echo "Validating Bicep files..."
          az bicep build --file infrastructure/bicep/main.bicep --outdir /tmp
          echo "âœ… Bicep syntax validation passed"

      - name: Lint Bicep (BicepLint)
        run: |
          echo "Running BicepLint..."
          az bicep build --file infrastructure/bicep/main.bicep --outdir /tmp
          # BicepLint is run automatically during build
          echo "âœ… BicepLint check passed"

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Azure Login (OIDC)
        uses: azure/login@a65d910e8af852a8061c627c456678983e180302
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Set Azure subscription context
        run: az account set --subscription ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "location=australiaeast" >> $GITHUB_OUTPUT
            echo "project_name=emergencyalerts2" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "location=australiaeast" >> $GITHUB_OUTPUT
            echo "project_name=emergencyalerts2" >> $GITHUB_OUTPUT
          fi

      - name: Build Bicep template
        run: |
          echo "Building Bicep template..."
          az bicep build --file infrastructure/bicep/main.bicep --outdir /tmp
          echo "âœ… Bicep build successful"

      - name: Validate infrastructure deployment
        run: |
          echo "Validating infrastructure deployment..."
          az deployment sub validate \
            --location ${{ steps.env.outputs.location }} \
            --template-file infrastructure/bicep/main.bicep \
            --parameters \
              location=${{ steps.env.outputs.location }} \
              environment=${{ steps.env.outputs.environment }} \
              projectName=${{ steps.env.outputs.project_name }} \
              mapsAadAppId=${{ secrets.MAPS_AAD_APP_ID }}

      - name: What-if analysis
        if: github.event_name == 'pull_request'
        run: |
          echo "Running what-if analysis..."
          az deployment sub what-if \
            --location ${{ steps.env.outputs.location }} \
            --template-file infrastructure/bicep/main.bicep \
            --parameters \
              location=${{ steps.env.outputs.location }} \
              environment=${{ steps.env.outputs.environment }} \
              projectName=${{ steps.env.outputs.project_name }} \
              mapsAadAppId=${{ secrets.MAPS_AAD_APP_ID }}

      - name: Deploy infrastructure
        if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
        id: deployment
        run: |
          echo "Deploying infrastructure..."
          DEPLOYMENT_OUTPUT=$(az deployment sub create \
            --name "infra-${{ steps.env.outputs.environment }}-$(date +%s)" \
            --location ${{ steps.env.outputs.location }} \
            --template-file infrastructure/bicep/main.bicep \
            --parameters \
              location=${{ steps.env.outputs.location }} \
              environment=${{ steps.env.outputs.environment }} \
              projectName=${{ steps.env.outputs.project_name }} \
              mapsAadAppId=${{ secrets.MAPS_AAD_APP_ID }} \
            --query "properties.outputs" \
            --output json)
          
          echo "Deployment outputs received (JSON format)"
          # Note: PostgreSQL admin password is auto-generated by Bicep and stored in Key Vault
          # Store deployment outputs in a temp file for later processing
          echo "$DEPLOYMENT_OUTPUT" > /tmp/deployment_outputs.json
          
          # Extract ACR name from deployment outputs
          echo "Extracting ACR name and API URL from deployment..."
          ACR_NAME=$(echo "$DEPLOYMENT_OUTPUT" | jq -r '.acrName.value // empty')
          API_URL=$(echo "$DEPLOYMENT_OUTPUT" | jq -r '.apiUrl.value // empty')
          
          if [ -z "$ACR_NAME" ]; then
            echo "âŒ ERROR: ACR name not found in deployment outputs"
            exit 1
          fi
          
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          
          echo "âœ… ACR Name: $ACR_NAME"
          echo "âœ… API URL: $API_URL"

      - name: Verify deployment
        if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
        run: |
          echo "Verifying infrastructure deployment..."
          
          # Get created resource group
          RG_NAME="${{ steps.env.outputs.project_name }}-${{ steps.env.outputs.environment }}-rg"
          
          echo "Resource Group: $RG_NAME"
          az group show --name $RG_NAME
          
          echo ""
          echo "Deployed resources:"
          az resource list --resource-group $RG_NAME --output table
          
          echo "âœ… Infrastructure deployment verified"

      - name: Output infrastructure details
        if: success()
        id: infra-details
        run: |
          RG_NAME="${{ steps.env.outputs.project_name }}-${{ steps.env.outputs.environment }}-rg"
          
          # Get AKS cluster name
          AKS_NAME=$(az aks list --resource-group $RG_NAME --query "[0].name" -o tsv)
          
          # Get ACR name from deployment outputs (extracted earlier in deployment step)
          if [ -z "${{ steps.deployment.outputs.acr_name }}" ]; then
            echo "âš ï¸  Using fallback: querying ACR from resource group"
            ACR_NAME=$(az acr list --resource-group $RG_NAME --query "[0].name" -o tsv)
          else
            ACR_NAME="${{ steps.deployment.outputs.acr_name }}"
          fi
          
          # Get API URL from deployment outputs
          API_URL="${{ steps.deployment.outputs.api_url }}"
          
          # Parse deployment outputs from temp file (stored earlier)
          if [ -f /tmp/deployment_outputs.json ]; then
            DEPLOYMENT_OUTPUTS=$(cat /tmp/deployment_outputs.json)
            
            # Extract PostgreSQL details from outputs (property name: value structure)
            # Use -r to get raw strings, provide defaults for missing values
            POSTGRES_FQDN=$(echo "$DEPLOYMENT_OUTPUTS" | jq -r '.postgresCoordinatorFqdn.value // "unknown"' 2>/dev/null || echo "unknown")
            POSTGRES_SERVER=$(echo "$DEPLOYMENT_OUTPUTS" | jq -r '.postgresClusterName.value // "unknown"' 2>/dev/null || echo "unknown")
            POSTGRES_DB=$(echo "$DEPLOYMENT_OUTPUTS" | jq -r '.postgresDatabaseName.value // "unknown"' 2>/dev/null || echo "unknown")
            POSTGRES_ADMIN=$(echo "$DEPLOYMENT_OUTPUTS" | jq -r '.postgresAdminLogin.value // "pgadmin"' 2>/dev/null || echo "pgadmin")
            MANAGED_IDENTITY_CLIENT_ID=$(echo "$DEPLOYMENT_OUTPUTS" | jq -r '.managedIdentityClientId.value // empty' 2>/dev/null || echo "")
          else
            echo "Warning: Deployment outputs file not found, using defaults"
            POSTGRES_FQDN="unknown"
            POSTGRES_SERVER="unknown"
            POSTGRES_DB="unknown"
            POSTGRES_ADMIN="pgadmin"
          fi

          if [ -z "$MANAGED_IDENTITY_CLIENT_ID" ]; then
            MANAGED_IDENTITY_NAME="${{ steps.env.outputs.project_name }}-${{ steps.env.outputs.environment }}-identity"
            MANAGED_IDENTITY_CLIENT_ID=$(az identity show \
              --resource-group "$RG_NAME" \
              --name "$MANAGED_IDENTITY_NAME" \
              --query clientId -o tsv)
          fi
          
          echo "Infrastructure deployed successfully:"
          echo "  Resource Group: $RG_NAME"
          echo "  AKS Cluster: $AKS_NAME"
          echo "  ACR Registry: $ACR_NAME"
          echo "  API URL: $API_URL"
          echo "  PostgreSQL Server: $POSTGRES_SERVER"
          echo "  PostgreSQL Database: $POSTGRES_DB"
          echo "  PostgreSQL Admin: $POSTGRES_ADMIN"
          
          # Save for downstream jobs using proper GitHub Actions output format
          # Use printf to handle special characters safely
          {
            printf "aks_name=%s\n" "$AKS_NAME"
            printf "acr_name=%s\n" "$ACR_NAME"
            printf "api_url=%s\n" "$API_URL"
            printf "postgres_fqdn=%s\n" "$POSTGRES_FQDN"
            printf "postgres_server=%s\n" "$POSTGRES_SERVER"
            printf "postgres_db=%s\n" "$POSTGRES_DB"
            printf "postgres_admin=%s\n" "$POSTGRES_ADMIN"
            printf "rg_name=%s\n" "$RG_NAME"
            printf "managed_identity_client_id=%s\n" "$MANAGED_IDENTITY_CLIENT_ID"
          } >> $GITHUB_OUTPUT

      - name: Configure PostgreSQL Entra ID admin
        if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
        run: |
          RG_NAME="${{ steps.infra-details.outputs.rg_name }}"
          POSTGRES_SERVER="${{ steps.infra-details.outputs.postgres_server }}"
          
          echo "Configuring PostgreSQL Entra ID admin..."
          
          CURRENT_USER_ID=$(az account show --query id -o tsv)
          CURRENT_USER_NAME=$(az account show --query user.name -o tsv)
          
          az postgres flexible-server ad-admin create \
            --resource-group $RG_NAME \
            --name $POSTGRES_SERVER \
            --object-id $CURRENT_USER_ID \
            --display-name $CURRENT_USER_NAME || \
            echo "âš ï¸  Entra ID admin may already be configured (continuing...)"
          
          echo "âœ… PostgreSQL Entra ID admin configured"

    outputs:
      aks_name: ${{ steps.infra-details.outputs.aks_name }}
      acr_name: ${{ steps.infra-details.outputs.acr_name }}
      api_url: ${{ steps.infra-details.outputs.api_url }}
      postgres_server: ${{ steps.infra-details.outputs.postgres_server }}
      postgres_fqdn: ${{ steps.infra-details.outputs.postgres_fqdn }}
      postgres_db: ${{ steps.infra-details.outputs.postgres_db }}
      postgres_admin: ${{ steps.infra-details.outputs.postgres_admin }}
      rg_name: ${{ steps.infra-details.outputs.rg_name }}
      managed_identity_client_id: ${{ steps.infra-details.outputs.managed_identity_client_id }}

  # ====================
  # Backend: Lint & Test
  # ====================
  backend-lint:
    name: Backend - Lint
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Setup .NET
        # SHA pin: actions/setup-dotnet v4.1.0 (2024-10-02)
        uses: actions/setup-dotnet@6bd8b7f7774af54e05809fcc5431931b3eb1ddee
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore backend/EmergencyAlerts.sln

      - name: Check code formatting
        run: dotnet format backend/EmergencyAlerts.sln --verify-no-changes --verbosity diagnostic

      - name: Run code analysis
        run: |
          # Build src projects with warnings as errors
          dotnet build backend/src/EmergencyAlerts.Domain/EmergencyAlerts.Domain.csproj /p:TreatWarningsAsErrors=true
          dotnet build backend/src/EmergencyAlerts.Application/EmergencyAlerts.Application.csproj /p:TreatWarningsAsErrors=true
          dotnet build backend/src/EmergencyAlerts.Infrastructure/EmergencyAlerts.Infrastructure.csproj /p:TreatWarningsAsErrors=true
          dotnet build backend/src/EmergencyAlerts.Api/EmergencyAlerts.Api.csproj /p:TreatWarningsAsErrors=true

      - name: Validate test compilation
        run: |
          # Ensure all test projects compile (Definition of Done requirement)
          dotnet build backend/tests/EmergencyAlerts.Domain.Tests/EmergencyAlerts.Domain.Tests.csproj
          dotnet build backend/tests/EmergencyAlerts.Application.Tests/EmergencyAlerts.Application.Tests.csproj
          dotnet build backend/tests/EmergencyAlerts.Infrastructure.Tests/EmergencyAlerts.Infrastructure.Tests.csproj
          dotnet build backend/tests/EmergencyAlerts.Api.Tests/EmergencyAlerts.Api.Tests.csproj
        continue-on-error: false  # Block merge if tests don't compile

  backend-test:
    name: Backend - Test
    runs-on: ubuntu-latest
    needs: backend-lint
    
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Setup .NET
        uses: actions/setup-dotnet@6bd8b7f7774af54e05809fcc5431931b3eb1ddee
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Run tests
        run: |
          dotnet test backend/EmergencyAlerts.sln --no-build --verbosity normal

  # ====================
  # Frontend: Lint & Test
  # ====================
  frontend-lint:
    name: Frontend - Lint
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Setup Node.js
        # SHA pin: actions/setup-node v4.1.0 (2024-10-24)
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: npm ci
        working-directory: frontend

      - name: Run ESLint
        run: npm run lint
        working-directory: frontend

      - name: Check TypeScript types
        run: npx tsc --noEmit
        working-directory: frontend

  frontend-test:
    name: Frontend - Test
    runs-on: ubuntu-latest
    needs: frontend-lint
    
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Setup Node.js
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: npm ci
        working-directory: frontend

      - name: Run unit tests
        run: npm test
        working-directory: frontend

      - name: Upload coverage reports
        # SHA pin: actions/upload-artifact v4.4.3 (2024-11-04)
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882
        with:
          name: frontend-coverage
          path: frontend/coverage/

  # ====================
  # Build & Push
  # ====================
  # build-backend job removed (was empty and caused YAML errors)
  run-migrations:
    name: Run EF Core Migrations
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Azure Login (OIDC)
        uses: azure/login@a65d910e8af852a8061c627c456678983e180302
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Get Key Vault secrets for PostgreSQL
        id: kv
        run: |
          RG_NAME="${{ needs.deploy-infrastructure.outputs.rg_name }}"
          KEYVAULT_NAME=$(az keyvault list --resource-group $RG_NAME --query "[0].name" -o tsv)
          POSTGRES_HOST="${{ needs.deploy-infrastructure.outputs.postgres_fqdn }}"
          POSTGRES_PORT="5432"
          POSTGRES_USER="${{ needs.deploy-infrastructure.outputs.postgres_admin }}"
          POSTGRES_DB="${{ needs.deploy-infrastructure.outputs.postgres_db }}"
          POSTGRES_PASSWORD=$(az keyvault secret show --vault-name $KEYVAULT_NAME --name "postgres-admin-password" --query "value" -o tsv)
          echo "connection_string=Server=$POSTGRES_HOST;Port=$POSTGRES_PORT;Database=$POSTGRES_DB;Username=$POSTGRES_USER;Password=$POSTGRES_PASSWORD;SSL Mode=Require;" >> $GITHUB_OUTPUT

      - name: Setup .NET
        uses: actions/setup-dotnet@6bd8b7f7774af54e05809fcc5431931b3eb1ddee
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore backend/EmergencyAlerts.sln

      - name: Run EF Core migrations
        run: |
          cd backend/src/EmergencyAlerts.Infrastructure
          dotnet ef database update --connection "${{ steps.kv.outputs.connection_string }}" --startup-project ../EmergencyAlerts.Api

      - name: Confirm schema created
        run: echo "âœ… EF Core migrations applied to Azure PostgreSQL."
  build-backend:
    name: Build & Push Backend
    runs-on: ubuntu-latest
    needs: [backend-test, backend-lint, deploy-infrastructure]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Extract Maps config from deployment outputs
        id: extract-maps
        run: |
          DEPLOYMENT_OUTPUTS_FILE="/tmp/deployment_outputs.json"
          if [ ! -f "$DEPLOYMENT_OUTPUTS_FILE" ]; then
            echo "âŒ ERROR: Deployment outputs file not found: $DEPLOYMENT_OUTPUTS_FILE"
            exit 1
          fi
          MAPS_ACCOUNT_NAME=$(jq -r '.mapsAccountName.value // empty' "$DEPLOYMENT_OUTPUTS_FILE")
          MAPS_ACCOUNT_CLIENT_ID=$(jq -r '.mapsAccountClientId.value // empty' "$DEPLOYMENT_OUTPUTS_FILE")
          MAPS_AAD_TENANT_ID="${{ env.AZURE_TENANT_ID }}"
          echo "maps_account_name=$MAPS_ACCOUNT_NAME" >> $GITHUB_OUTPUT
          echo "maps_account_client_id=$MAPS_ACCOUNT_CLIENT_ID" >> $GITHUB_OUTPUT
          echo "maps_aad_tenant_id=$MAPS_AAD_TENANT_ID" >> $GITHUB_OUTPUT
      - name: Inject Maps config from secrets
        run: |
          echo "Injecting Maps config from GitHub secrets into appsettings.json..."
          jq \
            --arg aadClientId "$MAPS_AAD_CLIENT_ID" \
            --arg aadAppId "$MAPS_AAD_APP_ID" \
            --arg aadTenantId "$MAPS_AAD_TENANT_ID" \
            --arg accountName "$MAPS_ACCOUNT_NAME" \
            '.Maps.AadClientId = $aadClientId | .Maps.AadAppId = $aadAppId | .Maps.AadTenantId = $aadTenantId | .Maps.AccountName = $accountName' \
            backend/src/EmergencyAlerts.Api/appsettings.json > backend/src/EmergencyAlerts.Api/appsettings.json.tmp
          mv backend/src/EmergencyAlerts.Api/appsettings.json.tmp backend/src/EmergencyAlerts.Api/appsettings.json
        env:
          MAPS_AAD_CLIENT_ID: ${{ secrets.MAPS_AAD_CLIENT_ID }}
          MAPS_AAD_APP_ID: ${{ secrets.MAPS_AAD_APP_ID }}
          MAPS_AAD_TENANT_ID: ${{ secrets.MAPS_AAD_TENANT_ID }}
          MAPS_ACCOUNT_NAME: ${{ secrets.MAPS_ACCOUNT_NAME }}
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Login to Azure Container Registry
        env:
          ACR_NAME: ${{ needs.deploy-infrastructure.outputs.acr_name }}
        run: |
          if [ -z "$ACR_NAME" ]; then
            echo "âŒ ERROR: ACR_NAME not available from infrastructure deployment"
            exit 1
          fi
          
          # Use token-based login for more reliable OIDC integration
          ACR_TOKEN=$(az acr login --name $ACR_NAME --expose-token --output tsv --query accessToken)
          echo $ACR_TOKEN | docker login $ACR_NAME.azurecr.io --username 00000000-0000-0000-0000-000000000000 --password-stdin
          echo "âœ… Successfully authenticated to $ACR_NAME.azurecr.io"

      - name: Build and push Docker image
        env:
          ACR_NAME: ${{ needs.deploy-infrastructure.outputs.acr_name }}
        run: |
          IMAGE_TAG="${GITHUB_SHA::7}"
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENVIRONMENT="prod"
          else
            ENVIRONMENT="dev"
          fi
          
          docker build \
            -t $ACR_NAME.azurecr.io/emergency-alerts-api:${IMAGE_TAG} \
            -t $ACR_NAME.azurecr.io/emergency-alerts-api:${ENVIRONMENT}-latest \
            -f backend/src/EmergencyAlerts.Api/Dockerfile \
            backend/
          
          docker push $ACR_NAME.azurecr.io/emergency-alerts-api:${IMAGE_TAG}
          docker push $ACR_NAME.azurecr.io/emergency-alerts-api:${ENVIRONMENT}-latest

      - name: Output image tags
        id: image-tags
        run: |
          echo "image_tag=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          echo "acr_image=${{ env.ACR_NAME }}.azurecr.io/emergency-alerts-api:${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

    outputs:
      image_tag: ${{ steps.image-tags.outputs.image_tag }}
      acr_image: ${{ steps.image-tags.outputs.acr_image }}

  build-frontend:
    name: Build & Push Frontend
    runs-on: ubuntu-latest
    needs: [frontend-test, frontend-lint, deploy-infrastructure]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Inject Maps config from deployment outputs
        run: |
          echo "Injecting Maps config from deployment outputs into appsettings.json..."
          jq \
            --arg aadClientId "$MAPS_ACCOUNT_CLIENT_ID" \
            --arg aadTenantId "$MAPS_AAD_TENANT_ID" \
            --arg accountName "$MAPS_ACCOUNT_NAME" \
            '.Maps.AadClientId = $aadClientId | .Maps.AadTenantId = $aadTenantId | .Maps.AccountName = $accountName' \
            backend/src/EmergencyAlerts.Api/appsettings.json > backend/src/EmergencyAlerts.Api/appsettings.json.tmp
          mv backend/src/EmergencyAlerts.Api/appsettings.json.tmp backend/src/EmergencyAlerts.Api/appsettings.json
        env:
          MAPS_ACCOUNT_CLIENT_ID: ${{ steps.extract-maps.outputs.maps_account_client_id }}
          MAPS_AAD_TENANT_ID: ${{ steps.extract-maps.outputs.maps_aad_tenant_id }}
          MAPS_ACCOUNT_NAME: ${{ steps.extract-maps.outputs.maps_account_name }}

      - name: Setup Node.js
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: npm ci
        working-directory: frontend

      - name: Build frontend
        run: npm run build
        working-directory: frontend
        env:
          VITE_API_URL: ${{ needs.deploy-infrastructure.outputs.api_url }}

      - name: Verify frontend bundle API URL
        run: |
          if [ -z "${VITE_API_URL}" ]; then
            echo "âŒ ERROR: VITE_API_URL is empty"
            exit 1
          fi

          if ! grep -F "${VITE_API_URL}" -n dist/assets/*.js; then
            echo "âŒ ERROR: Built bundle does not contain VITE_API_URL=${VITE_API_URL}"
            exit 1
          fi

          echo "âœ… Frontend bundle contains expected API URL"
        working-directory: frontend
        env:
          VITE_API_URL: ${{ needs.deploy-infrastructure.outputs.api_url }}

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Login to Azure Container Registry
        env:
          ACR_NAME: ${{ needs.deploy-infrastructure.outputs.acr_name }}
        run: |
          if [ -z "$ACR_NAME" ]; then
            echo "âŒ ERROR: ACR_NAME not available from infrastructure deployment"
            exit 1
          fi
          
          # Use token-based login for more reliable OIDC integration
          ACR_TOKEN=$(az acr login --name $ACR_NAME --expose-token --output tsv --query accessToken)
          echo $ACR_TOKEN | docker login $ACR_NAME.azurecr.io --username 00000000-0000-0000-0000-000000000000 --password-stdin
          echo "âœ… Successfully authenticated to $ACR_NAME.azurecr.io"

      - name: Build and push Docker image
        env:
          ACR_NAME: ${{ needs.deploy-infrastructure.outputs.acr_name }}
        run: |
          IMAGE_TAG="${GITHUB_SHA::7}"
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENVIRONMENT="prod"
          else
            ENVIRONMENT="dev"
          fi


          # Set public API URL for frontend from infrastructure deployment outputs
          PUBLIC_API_URL="${{ needs.deploy-infrastructure.outputs.api_url }}"
          echo "Using PUBLIC_API_URL=$PUBLIC_API_URL for frontend build"
          docker build \
            --build-arg VITE_API_URL="$PUBLIC_API_URL" \
            -t $ACR_NAME.azurecr.io/emergency-alerts-frontend:${IMAGE_TAG} \
            -t $ACR_NAME.azurecr.io/emergency-alerts-frontend:${ENVIRONMENT}-latest \
            -f frontend/Dockerfile \
            frontend/
          
          docker push $ACR_NAME.azurecr.io/emergency-alerts-frontend:${IMAGE_TAG}
          docker push $ACR_NAME.azurecr.io/emergency-alerts-frontend:${ENVIRONMENT}-latest

      - name: Output image tags
        id: image-tags
        env:
          ACR_NAME: ${{ needs.deploy-infrastructure.outputs.acr_name }}
        run: |
          echo "image_tag=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          echo "acr_image=$ACR_NAME.azurecr.io/emergency-alerts-frontend:${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

    outputs:
      image_tag: ${{ steps.image-tags.outputs.image_tag }}
      acr_image: ${{ steps.image-tags.outputs.acr_image }}
  deploy:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend, deploy-infrastructure]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Azure Login (OIDC)
        uses: azure/login@a65d910e8af852a8061c627c456678983e180302
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.deploy-infrastructure.outputs.rg_name }} \
            --name ${{ needs.deploy-infrastructure.outputs.aks_name }} \
            --overwrite-existing

      - name: Create Kubernetes namespace and resources
        env:
          ACR_NAME: ${{ needs.deploy-infrastructure.outputs.acr_name }}
          IMAGE_TAG: ${{ needs.build-backend.outputs.image_tag }}
          MANAGED_IDENTITY_CLIENT_ID: ${{ needs.deploy-infrastructure.outputs.managed_identity_client_id }}
          AZURE_TENANT_ID: ${{ env.AZURE_TENANT_ID }}
        run: |
          echo "Creating Kubernetes namespace and base resources..."
          RG_NAME="${{ needs.deploy-infrastructure.outputs.rg_name }}"
          SUBSCRIPTION_ID=$(az account show --query id -o tsv)
          DNS_SUFFIX=$(echo "$SUBSCRIPTION_ID" | tr -d '-' | cut -c1-6)
          API_DNS_LABEL="${RG_NAME%-rg}-api"
          if [ -n "$DNS_SUFFIX" ]; then
            FRONTEND_DNS_LABEL="${RG_NAME%-rg}-frontend-${DNS_SUFFIX}"
            SIGNALR_DNS_LABEL="${RG_NAME%-rg}-signalr-${DNS_SUFFIX}"
          else
            FRONTEND_DNS_LABEL="${RG_NAME%-rg}-frontend"
            SIGNALR_DNS_LABEL="${RG_NAME%-rg}-signalr"
          fi
          
          # Substitute environment variables in manifests before applying
          cat infrastructure/k8s/deployment.yaml | \
            sed "s|\${ACR_NAME}|${ACR_NAME}|g" | \
            sed "s|\${IMAGE_TAG}|${IMAGE_TAG}|g" | \
            sed "s|\${MANAGED_IDENTITY_CLIENT_ID}|${MANAGED_IDENTITY_CLIENT_ID}|g" | \
            sed "s|\${AZURE_TENANT_ID}|${AZURE_TENANT_ID}|g" | \
            sed "s|\${API_DNS_LABEL}|${API_DNS_LABEL}|g" | \
            sed "s|\${FRONTEND_DNS_LABEL}|${FRONTEND_DNS_LABEL}|g" | \
            sed "s|\${SIGNALR_DNS_LABEL}|${SIGNALR_DNS_LABEL}|g" | \
            kubectl apply -f -
          

          # Apply RBAC policies (no variable substitution needed)
          kubectl apply -f infrastructure/k8s/rbac.yaml

          # Apply all NetworkPolicies (including frontend-to-backend and restrictive policies)
          kubectl apply -f infrastructure/k8s/network-policy-fixed.yaml
          kubectl apply -f infrastructure/k8s/emergency-alerts-api-allow-frontend.yaml

          echo "âœ… Kubernetes namespace, RBAC, and network policies created"

          # Verify deployments were created
          echo "Verifying deployments..."
          kubectl get deployment -n emergency-alerts
          kubectl get service -n emergency-alerts

      - name: Install cert-manager (CRDs + controller)
        shell: pwsh
        run: |
          ./infrastructure/scripts/setup-aks-post-deployment.ps1 `
            -AksClusterName ${{ needs.deploy-infrastructure.outputs.aks_name }} `
            -Environment prod `
            -Namespace emergency-alerts

      - name: Apply ingress configuration
        run: kubectl apply -f infrastructure/k8s/ingress.yaml

      - name: Update K8s ConfigMap and Secrets with database connection
        run: |
          POSTGRES_HOST="${{ needs.deploy-infrastructure.outputs.postgres_fqdn }}"
          POSTGRES_PORT="5432"
          POSTGRES_USER="${{ needs.deploy-infrastructure.outputs.postgres_admin }}"
          POSTGRES_DB="${{ needs.deploy-infrastructure.outputs.postgres_db }}"
          
          echo "Retrieving Azure service endpoints..."
          
          # Get Azure service endpoints from deployed infrastructure
          RG_NAME="${{ needs.deploy-infrastructure.outputs.rg_name }}"
          SUBSCRIPTION_ID=$(az account show --query id -o tsv)
          DNS_SUFFIX=$(echo "$SUBSCRIPTION_ID" | tr -d '-' | cut -c1-6)
          if [ -n "$DNS_SUFFIX" ]; then
            FRONTEND_DNS_LABEL="${RG_NAME%-rg}-frontend-${DNS_SUFFIX}"
          else
            FRONTEND_DNS_LABEL="${RG_NAME%-rg}-frontend"
          fi
          FRONTEND_URL="http://${FRONTEND_DNS_LABEL}.australiaeast.cloudapp.azure.com"
          
          # Get Key Vault details
          KEYVAULT_NAME=$(az keyvault list --resource-group $RG_NAME --query "[0].name" -o tsv)
          KEY_VAULT_URI="https://${KEYVAULT_NAME}.vault.azure.net/"
          
          # Get PostgreSQL password from Key Vault
          POSTGRES_PASSWORD=$(az keyvault secret show --vault-name $KEYVAULT_NAME --name "postgres-admin-password" --query "value" -o tsv)
          
          # Get App Configuration endpoint (if exists)
          APP_CONFIG_NAME=$(az appconfig list --resource-group $RG_NAME --query "[0].name" -o tsv || echo "")
          if [ -n "$APP_CONFIG_NAME" ]; then
            APP_CONFIG_ENDPOINT=$(az appconfig show --name $APP_CONFIG_NAME --resource-group $RG_NAME --query "endpoint" -o tsv)
          else
            APP_CONFIG_ENDPOINT="https://placeholder.azconfig.io"
          fi
          
          # Get Azure Communication Services connection string (if exists)
          ACS_HOST=$(az communication list --resource-group $RG_NAME --query "[0].hostName" -o tsv 2>/dev/null || echo "")
          if [ -n "$ACS_HOST" ]; then
            ACS_ENDPOINT="https://${ACS_HOST}/"
          else
            ACS_ENDPOINT="https://placeholder.communication.azure.com/"
          fi
          
          # Build properly formatted connection string
          CONNECTION_STRING="Server=${POSTGRES_HOST};Port=${POSTGRES_PORT};Database=${POSTGRES_DB};Username=${POSTGRES_USER};Password=${POSTGRES_PASSWORD};SSL Mode=Require;"
          CORS_ALLOWED_ORIGINS="${FRONTEND_URL},http://localhost:5173,http://localhost:3000"
          AUTH_ALLOW_ANONYMOUS="${AUTH_ALLOW_ANONYMOUS:-true}"
          
          # SECURITY: Create/update Kubernetes Secret for sensitive database credentials
          echo "Creating/updating Secret with database credentials..."
          kubectl create secret generic emergency-alerts-db-credentials \
            --namespace emergency-alerts \
            --from-literal=POSTGRES_PASSWORD="${POSTGRES_PASSWORD}" \
            --from-literal=ConnectionStrings__EmergencyAlertsDb="${CONNECTION_STRING}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "Updating ConfigMap with non-sensitive configuration..."
          
          # Create patch JSON with non-sensitive fields only (password removed)
          cat > /tmp/configmap-patch.json <<EOF
          {
            "data": {
              "AppConfiguration__Endpoint": "${APP_CONFIG_ENDPOINT}",
              "KeyVault__VaultUri": "${KEY_VAULT_URI}",
              "AzureCommunicationServices__Endpoint": "${ACS_ENDPOINT}",
              "Auth__AllowAnonymous": "${AUTH_ALLOW_ANONYMOUS}",
              "POSTGRES_HOST": "${POSTGRES_HOST}",
              "POSTGRES_PORT": "${POSTGRES_PORT}",
              "POSTGRES_USER": "${POSTGRES_USER}",
              "POSTGRES_DATABASE": "${POSTGRES_DB}",
              "Cors__AllowedOrigins": "${CORS_ALLOWED_ORIGINS}"
            }
          }
          EOF
          
          # Patch the existing ConfigMap with actual values (no secrets)
          kubectl patch configmap emergency-alerts-config \
            -n emergency-alerts \
            --type merge \
            --patch-file /tmp/configmap-patch.json
          
          echo "âœ… Secret created with database credentials (POSTGRES_PASSWORD, ConnectionString)"
          echo "âœ… ConfigMap updated with non-sensitive configuration"
          
          # Verify update (show ConfigMap without secrets)
          kubectl get configmap emergency-alerts-config -n emergency-alerts -o yaml | grep -A 15 "data:"

      - name: Update deployment image
        run: |
          IMAGE_TAG="${GITHUB_SHA::7}"
          ACR_NAME="${{ needs.deploy-infrastructure.outputs.acr_name }}"
          
          # Update backend deployment
          kubectl set image deployment/emergency-alerts-api \
            api=$ACR_NAME.azurecr.io/emergency-alerts-api:${IMAGE_TAG} \
            -n emergency-alerts
          
          # Update frontend deployment if it exists
          if kubectl get deployment/emergency-alerts-frontend -n emergency-alerts &>/dev/null; then
            echo "Frontend deployment found, updating image..."
            kubectl set image deployment/emergency-alerts-frontend \
              frontend=$ACR_NAME.azurecr.io/emergency-alerts-frontend:${IMAGE_TAG} \
              -n emergency-alerts
          else
            echo "â„¹ï¸  Frontend deployment not found in Kubernetes - may be served from CDN/Static Web App"
          fi

      - name: Wait for rollout
        run: |
          echo "Waiting for backend deployment rollout..."
          kubectl rollout status deployment/emergency-alerts-api -n emergency-alerts --timeout=5m
          
          # Wait for frontend only if it exists
          if kubectl get deployment/emergency-alerts-frontend -n emergency-alerts &>/dev/null; then
            echo "Waiting for frontend deployment rollout..."
            kubectl rollout status deployment/emergency-alerts-frontend -n emergency-alerts --timeout=5m
          fi

      - name: Verify deployment
        run: |
          kubectl get pods -n emergency-alerts
          kubectl get services -n emergency-alerts
          
          # Check if backend pods are running
          BACKEND_READY=$(kubectl get deployment emergency-alerts-api -n emergency-alerts -o jsonpath='{.status.readyReplicas}')
          
          if [ "$BACKEND_READY" -lt 1 ]; then
            echo "ERROR: Backend deployment has no ready replicas"
            exit 1
          fi
          
          # Check frontend only if it exists
          if kubectl get deployment/emergency-alerts-frontend -n emergency-alerts &>/dev/null; then
            FRONTEND_READY=$(kubectl get deployment emergency-alerts-frontend -n emergency-alerts -o jsonpath='{.status.readyReplicas}')
            if [ "$FRONTEND_READY" -lt 1 ]; then
              echo "ERROR: Frontend deployment has no ready replicas"
              exit 1
            fi
            echo "âœ… Deployment successful - ${BACKEND_READY} backend pods, ${FRONTEND_READY} frontend pods ready"
          else
            echo "âœ… Deployment successful - ${BACKEND_READY} backend pods ready (frontend served externally)"
          fi

      - name: Run smoke tests
        run: |
          # Wait for service to be accessible
          sleep 30
          
          # Health check from within a running API pod (avoids network policy restrictions)
          POD_NAME=$(kubectl get pods -n emergency-alerts -l app=emergency-alerts-api -o jsonpath='{.items[0].metadata.name}')
          if [ -z "$POD_NAME" ]; then
            echo "ERROR: No backend pod found for smoke test"
            exit 1
          fi
          kubectl exec -n emergency-alerts "$POD_NAME" -- \
            curl -fsS http://127.0.0.1:5000/health/ready
          
          echo "âœ… Smoke tests passed"

      - name: Post deployment comment
        if: github.event_name == 'push'
        # SHA pin: actions/github-script v7.0.1 (2024-01-31)
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          script: |
            const imageTag = process.env.GITHUB_SHA.substring(0, 7);
            const acrName = '${{ needs.deploy-infrastructure.outputs.acr_name }}';
            const comment = `### ðŸš€ Deployment Complete
            
            **Environment:** Production  
            **Image Tag:** \`${imageTag}\`  
            **Backend Image:** \`${acrName}.azurecr.io/emergency-alerts-api:${imageTag}\`
            
            **Deployed Resources:**
            - Backend API: ${{ needs.build-backend.outputs.image_tag }}
            - Frontend: Built and stored in ACR (may be served from CDN/Static Web App)
            
            **Database:** PostgreSQL Flexible Server configured with Drasi CDC source
            **Next Steps:**
            - Monitor application health
            - Check deployment logs: \`kubectl logs -n emergency-alerts -l app=emergency-alerts-api -f\`
            `;
            
            github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: comment
            })

  # ====================
  # Deploy Drasi Queries
  # ====================
  deploy-drasi:
    name: Deploy Drasi Queries
    runs-on: ubuntu-latest
    needs: [deploy, deploy-infrastructure]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Azure Login (OIDC)
        uses: azure/login@a65d910e8af852a8061c627c456678983e180302
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.deploy-infrastructure.outputs.rg_name }} \
            --name ${{ needs.deploy-infrastructure.outputs.aks_name }} \
            --overwrite-existing

      - name: Verify PostgreSQL connectivity
        run: |
          echo "Verifying PostgreSQL accessibility from AKS..."
          
          POSTGRES_HOST=$(kubectl get configmap emergency-alerts-config -n emergency-alerts -o jsonpath='{.data.POSTGRES_HOST}' 2>/dev/null || echo "unknown")
          POSTGRES_PORT=$(kubectl get configmap emergency-alerts-config -n emergency-alerts -o jsonpath='{.data.POSTGRES_PORT}' 2>/dev/null || echo "5432")
          
          if [ "$POSTGRES_HOST" != "unknown" ]; then
            echo "PostgreSQL endpoint: $POSTGRES_HOST:$POSTGRES_PORT"
            
            # Test DNS resolution and connectivity
            echo "Testing DNS resolution..."
            kubectl run dns-test \
              --image=alpine:latest \
              --restart=Never \
              --rm -i \
              -n emergency-alerts \
              -- nslookup "$POSTGRES_HOST" || \
              { echo "âš ï¸  DNS resolution test failed (may be expected in some networks)"; }
            
            echo "âœ… PostgreSQL endpoint verified (authentication via managed identity)"
          else
            echo "âš ï¸  ConfigMap not found - skipping connectivity test"
          fi

      - name: Setup Drasi CLI
        run: |
          # Install Drasi CLI for configuration and deployment
          # Use the official installer to avoid stale release asset paths
          export DRASI_INSTALL_DIR="$HOME/.local/bin"
          mkdir -p "$DRASI_INSTALL_DIR"
          curl -fsSL https://raw.githubusercontent.com/drasi-project/drasi-platform/main/cli/installers/install-drasi-cli.sh | /bin/bash
          echo "$DRASI_INSTALL_DIR" >> $GITHUB_PATH
          drasi version

      - name: Ensure Drasi installed
        run: |
          DRASI_NAMESPACE="drasi-system"
          
          # Bind Drasi CLI to the current kubectl context (AKS)
          drasi env kube
          
          # Install Drasi if missing, control plane absent, or API unavailable
          NEED_INIT=0
          if ! kubectl get ns "$DRASI_NAMESPACE" >/dev/null 2>&1; then
            echo "Drasi namespace not found; will install Drasi."
            NEED_INIT=1
          else
            DEPLOY_COUNT=$(kubectl get deployment -n "$DRASI_NAMESPACE" --no-headers 2>/dev/null | wc -l | tr -d ' ')
            if [ "${DEPLOY_COUNT:-0}" -eq 0 ]; then
              echo "Drasi namespace exists but no deployments found; will install Drasi."
              NEED_INIT=1
            elif ! drasi list source -n "$DRASI_NAMESPACE" >/dev/null 2>&1; then
              echo "Drasi API not available; will install Drasi."
              NEED_INIT=1
            fi
          fi

          if [ "$NEED_INIT" -eq 1 ]; then
            set +e
            for i in {1..3}; do
              echo "drasi init attempt $i/3..."
              drasi init -n "$DRASI_NAMESPACE"
              if [ $? -eq 0 ]; then
                break
              fi
              echo "drasi init failed; waiting 30s before retry..."
              sleep 30
            done
            set -e
          fi

          # Wait for Drasi control plane deployments to appear, then become ready
          for i in {1..18}; do
            DEPLOY_COUNT=$(kubectl get deployment -n "$DRASI_NAMESPACE" --no-headers 2>/dev/null | wc -l | tr -d ' ')
            if [ "${DEPLOY_COUNT:-0}" -gt 0 ]; then
              break
            fi
            echo "Waiting for Drasi deployments to appear... ($i/18)"
            sleep 10
          done
          DEPLOY_COUNT=$(kubectl get deployment -n "$DRASI_NAMESPACE" --no-headers 2>/dev/null | wc -l | tr -d ' ')
          if [ "${DEPLOY_COUNT:-0}" -gt 0 ]; then
            kubectl wait --for=condition=available --timeout=900s deployment --all -n "$DRASI_NAMESPACE"
          else
            echo "ERROR: No Drasi deployments found after waiting for control plane."
            exit 1
          fi
          
          # Wait for Drasi API to be available
          for i in {1..6}; do
            if drasi list source -n "$DRASI_NAMESPACE" >/dev/null 2>&1; then
              echo "Drasi API available."
              exit 0
            fi
            echo "Waiting for Drasi API... ($i/6)"
            sleep 10
          done
          
          echo "ERROR: Drasi API still unavailable after init"
          exit 1

      - name: Deploy Drasi PostgreSQL source
        run: |
          echo "Deploying Drasi PostgreSQL CDC source..."
          
          # Get PostgreSQL connection details from ConfigMap (non-sensitive)
          POSTGRES_HOST=$(kubectl get configmap emergency-alerts-config -n emergency-alerts -o jsonpath='{.data.POSTGRES_HOST}')
          POSTGRES_PORT=$(kubectl get configmap emergency-alerts-config -n emergency-alerts -o jsonpath='{.data.POSTGRES_PORT}')
          POSTGRES_USER=$(kubectl get configmap emergency-alerts-config -n emergency-alerts -o jsonpath='{.data.POSTGRES_USER}')
          POSTGRES_DATABASE=$(kubectl get configmap emergency-alerts-config -n emergency-alerts -o jsonpath='{.data.POSTGRES_DATABASE}')
          
          # Get POSTGRES_PASSWORD from Secret (sensitive data)
          POSTGRES_PASSWORD=$(kubectl get secret emergency-alerts-db-credentials -n emergency-alerts -o jsonpath='{.data.POSTGRES_PASSWORD}' | base64 -d)
          
          # Create temporary source YAML with environment variables substituted
          cat infrastructure/drasi/sources/postgres-cdc.yaml | \
            sed "s|\${POSTGRES_HOST}|${POSTGRES_HOST}|g" | \
            sed "s|\${POSTGRES_PORT}|${POSTGRES_PORT}|g" | \
            sed "s|\${POSTGRES_USER}|${POSTGRES_USER}|g" | \
            sed "s|\${POSTGRES_PASSWORD}|${POSTGRES_PASSWORD}|g" | \
            sed "s|\${POSTGRES_DATABASE}|${POSTGRES_DATABASE}|g" | \
            > /tmp/postgres-cdc-resolved.yaml
          
          # Use Drasi CLI for source configuration (NOT kubectl)
          drasi apply -f /tmp/postgres-cdc-resolved.yaml -n drasi-system
          
          echo "âœ… Drasi PostgreSQL source deployed"

      - name: Deploy Drasi queries
        run: |
          echo "Deploying Drasi queries..."
          
          # Use Drasi CLI for query deployment (NOT kubectl)
          drasi apply -f infrastructure/drasi/queries/emergency-alerts.yaml -n drasi-system
          
          echo "âœ… Drasi queries deployed"

      - name: Deploy Drasi reactions
        env:
          DRASI_REACTION_TOKEN: ${{ secrets.DRASI_REACTION_TOKEN }}
        run: |
          echo "Deploying Drasi reactions..."
          
          DRASI_HTTP_REACTION_BASE_URL="http://emergency-alerts-api.emergency-alerts.svc.cluster.local/api/v1/drasi/reactions"
          if [ -z "${DRASI_REACTION_TOKEN}" ]; then
            DRASI_REACTION_TOKEN="cluster-local"
          fi
          
          # Ensure reaction auth secret exists for Drasi reaction configuration
          kubectl create secret generic drasi-reaction-auth \
            --from-literal=token="${DRASI_REACTION_TOKEN}" \
            -n drasi-system \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Resolve reaction manifest variables
          cat infrastructure/drasi/reactions/emergency-alerts-http.yaml | \
            sed "s|\${DRASI_HTTP_REACTION_BASE_URL}|${DRASI_HTTP_REACTION_BASE_URL}|g" | \
            sed "s|\${DRASI_REACTION_TOKEN}|${DRASI_REACTION_TOKEN}|g" | \
            > /tmp/drasi-reactions-resolved.yaml
          
          # Use Drasi CLI for reaction deployment (NOT kubectl)
          drasi apply -f /tmp/drasi-reactions-resolved.yaml -n drasi-system
          
          echo "âœ… Drasi reactions deployed"

      - name: Verify Drasi deployment
        run: |
          echo "Verifying Drasi configuration..."
          
          # Wait for source to be ready (up to 30 seconds)
          for i in {1..6}; do
            SOURCE_STATUS=$(drasi list source -n drasi-system -o json | jq -r '.[0].status // "Unknown"')
            echo "PostgreSQL source status: $SOURCE_STATUS (attempt $i/6)"
            if [[ "$SOURCE_STATUS" == "Running" ]]; then
              break
            fi
            sleep 5
          done
          
          # List all deployed sources
          echo "Deployed sources:"
          drasi list source -n drasi-system
          
          # List all deployed queries
          echo "Deployed queries:"
          drasi list query -n drasi-system

          # List all deployed reactions
          echo "Deployed reactions:"
          drasi list reaction -n drasi-system
          
          # Check all queries are deployed and running
          QUERY_COUNT=$(drasi list query -n drasi-system -o json | jq '. | length')
          if [ "$QUERY_COUNT" -lt 8 ]; then
            echo "WARNING: Expected 8 Drasi queries, found $QUERY_COUNT (may still be deploying)"
          fi
          
          # Verify no queries in TerminalError state
          ERROR_COUNT=$(drasi list query -n drasi-system -o json | jq '[.[] | select(.status | contains("TerminalError"))] | length')
          if [ "$ERROR_COUNT" -gt 0 ]; then
            echo "ERROR: $ERROR_COUNT queries in TerminalError state"
            drasi list query -n drasi-system
            exit 1
          fi
          
          echo "âœ… All $QUERY_COUNT Drasi queries deployed and running successfully"

  # ====================
  # Security Scan
  # ====================
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Run Trivy vulnerability scanner
        # SHA pin: aquasecurity/trivy-action v0.28.0 (2024-11-11)
        uses: aquasecurity/trivy-action@18f2510ee396bbf400402947b394f2dd8c87dbb0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results to GitHub Security
        # SHA pin: github/codeql-action v3.27.0 (2024-11-01)
        uses: github/codeql-action/upload-sarif@4f3212b61783c3c68e8309a0f18a699764811cda
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Check for critical vulnerabilities
        run: |
          CRITICAL=$(grep -c "CRITICAL" trivy-results.sarif || true)
          if [ "$CRITICAL" -gt 0 ]; then
            echo "ERROR: Found $CRITICAL critical vulnerabilities"
            exit 1
          fi
